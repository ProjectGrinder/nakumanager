// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: team.sql

package db

import (
	"context"
	"database/sql"
)

const addMemberToTeam = `-- name: AddMemberToTeam :exec
INSERT OR IGNORE INTO team_members (team_id, user_id)
VALUES (?, ?)
`

type AddMemberToTeamParams struct {
	TeamID string `json:"team_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) AddMemberToTeam(ctx context.Context, arg AddMemberToTeamParams) error {
	_, err := q.db.ExecContext(ctx, addMemberToTeam, arg.TeamID, arg.UserID)
	return err
}

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (id, name, workspace_id)
VALUES (?, ?, ?)
`

type CreateTeamParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	WorkspaceID string `json:"workspace_id"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) error {
	_, err := q.db.ExecContext(ctx, createTeam, arg.ID, arg.Name, arg.WorkspaceID)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams WHERE id = ?
`

func (q *Queries) DeleteTeam(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTeam, id)
	return err
}

const deleteTeamFromTeamMembers = `-- name: DeleteTeamFromTeamMembers :exec
DELETE FROM team_members WHERE team_id = ?
`

func (q *Queries) DeleteTeamFromTeamMembers(ctx context.Context, teamID string) error {
	_, err := q.db.ExecContext(ctx, deleteTeamFromTeamMembers, teamID)
	return err
}

const getLeaderByTeamID = `-- name: GetLeaderByTeamID :one
SELECT leader_id
FROM teams
WHERE id = ?
`

func (q *Queries) GetLeaderByTeamID(ctx context.Context, id string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getLeaderByTeamID, id)
	var leader_id sql.NullString
	err := row.Scan(&leader_id)
	return leader_id, err
}

const getOwnerByTeamID = `-- name: GetOwnerByTeamID :one
SELECT w.owner_id
FROM teams t
JOIN workspaces w ON t.workspace_id = w.id
WHERE t.id = ?
`

func (q *Queries) GetOwnerByTeamID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getOwnerByTeamID, id)
	var owner_id string
	err := row.Scan(&owner_id)
	return owner_id, err
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT id, name, workspace_id, leader_id
FROM teams
WHERE id = ?
`

func (q *Queries) GetTeamByID(ctx context.Context, id string) (Team, error) {
	row := q.db.QueryRowContext(ctx, getTeamByID, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.WorkspaceID,
		&i.LeaderID,
	)
	return i, err
}

const getTeamsByUserID = `-- name: GetTeamsByUserID :many
SELECT t.id, t.name, t.workspace_id, t.leader_id
FROM teams t
JOIN team_members tm ON t.id = tm.team_id
WHERE tm.user_id = ?
`

func (q *Queries) GetTeamsByUserID(ctx context.Context, userID string) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, getTeamsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.WorkspaceID,
			&i.LeaderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isMemberInTeam = `-- name: IsMemberInTeam :one
SELECT COUNT(*) AS count
FROM team_members
WHERE team_id = ? AND user_id = ?
`

type IsMemberInTeamParams struct {
	TeamID string `json:"team_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) IsMemberInTeam(ctx context.Context, arg IsMemberInTeamParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isMemberInTeam, arg.TeamID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isTeamExists = `-- name: IsTeamExists :one
SELECT COUNT(*) AS count
FROM teams
WHERE id = ?
`

func (q *Queries) IsTeamExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isTeamExists, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listIssuesByUserID = `-- name: ListIssuesByUserID :many
SELECT i.id, i.title, i.status, i.priority, i.project_id, i.assignee
FROM issues i
JOIN project_members pm ON i.project_id = pm.project_id
WHERE pm.user_id = ?
`

type ListIssuesByUserIDRow struct {
	ID        string         `json:"id"`
	Title     string         `json:"title"`
	Status    string         `json:"status"`
	Priority  sql.NullString `json:"priority"`
	ProjectID sql.NullString `json:"project_id"`
	Assignee  sql.NullString `json:"assignee"`
}

func (q *Queries) ListIssuesByUserID(ctx context.Context, userID string) ([]ListIssuesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListIssuesByUserIDRow{}
	for rows.Next() {
		var i ListIssuesByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.ProjectID,
			&i.Assignee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMembers = `-- name: ListTeamMembers :many
SELECT u.id, u.username, u.email
FROM users u
JOIN team_members tm ON u.id = tm.user_id
WHERE tm.team_id = ?
`

type ListTeamMembersRow struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) ListTeamMembers(ctx context.Context, teamID string) ([]ListTeamMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamMembersRow{}
	for rows.Next() {
		var i ListTeamMembersRow
		if err := rows.Scan(&i.ID, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, workspace_id, leader_id
FROM teams
ORDER BY name
`

func (q *Queries) ListTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, listTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.WorkspaceID,
			&i.LeaderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMemberFromTeam = `-- name: RemoveMemberFromTeam :exec
DELETE FROM team_members
WHERE team_id = ? AND user_id = ?
`

type RemoveMemberFromTeamParams struct {
	TeamID string `json:"team_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) RemoveMemberFromTeam(ctx context.Context, arg RemoveMemberFromTeamParams) error {
	_, err := q.db.ExecContext(ctx, removeMemberFromTeam, arg.TeamID, arg.UserID)
	return err
}

const renameTeam = `-- name: RenameTeam :exec
UPDATE teams
SET name = ?
WHERE id = ?
`

type RenameTeamParams struct {
	Name string `json:"name"`
	ID   string `json:"id"`
}

func (q *Queries) RenameTeam(ctx context.Context, arg RenameTeamParams) error {
	_, err := q.db.ExecContext(ctx, renameTeam, arg.Name, arg.ID)
	return err
}

const setLeaderToTeam = `-- name: SetLeaderToTeam :exec
UPDATE teams
SET leader_id = ?
WHERE id = ?
`

type SetLeaderToTeamParams struct {
	LeaderID sql.NullString `json:"leader_id"`
	ID       string         `json:"id"`
}

func (q *Queries) SetLeaderToTeam(ctx context.Context, arg SetLeaderToTeamParams) error {
	_, err := q.db.ExecContext(ctx, setLeaderToTeam, arg.LeaderID, arg.ID)
	return err
}
