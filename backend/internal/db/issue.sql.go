// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: issue.sql

package db

import (
	"context"
	"database/sql"
)

const addAssigneeToIssue = `-- name: AddAssigneeToIssue :exec
INSERT OR IGNORE INTO issue_assignees (issue_id, user_id)
VALUES (?, ?)
`

type AddAssigneeToIssueParams struct {
	IssueID string `json:"issue_id"`
	UserID  string `json:"user_id"`
}

func (q *Queries) AddAssigneeToIssue(ctx context.Context, arg AddAssigneeToIssueParams) error {
	_, err := q.db.ExecContext(ctx, addAssigneeToIssue, arg.IssueID, arg.UserID)
	return err
}

const createIssue = `-- name: CreateIssue :exec
INSERT INTO issues (
    id, title, content, priority, status, project_id, team_id, assignee,
    start_date, end_date, label, owner_id
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateIssueParams struct {
	ID        string         `json:"id"`
	Title     string         `json:"title"`
	Content   sql.NullString `json:"content"`
	Priority  sql.NullString `json:"priority"`
	Status    string         `json:"status"`
	ProjectID sql.NullString `json:"project_id"`
	TeamID    string         `json:"team_id"`
	Assignee  sql.NullString `json:"assignee"`
	StartDate sql.NullTime   `json:"start_date"`
	EndDate   sql.NullTime   `json:"end_date"`
	Label     sql.NullString `json:"label"`
	OwnerID   string         `json:"owner_id"`
}

func (q *Queries) CreateIssue(ctx context.Context, arg CreateIssueParams) error {
	_, err := q.db.ExecContext(ctx, createIssue,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.Priority,
		arg.Status,
		arg.ProjectID,
		arg.TeamID,
		arg.Assignee,
		arg.StartDate,
		arg.EndDate,
		arg.Label,
		arg.OwnerID,
	)
	return err
}

const deleteIssue = `-- name: DeleteIssue :exec
DELETE FROM issues WHERE id = ?
`

func (q *Queries) DeleteIssue(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteIssue, id)
	return err
}

const getIssueByID = `-- name: GetIssueByID :one
SELECT id, title, content, priority, status, assignee, project_id, team_id, start_date, end_date, label, owner_id
FROM issues
WHERE id = ?
`

func (q *Queries) GetIssueByID(ctx context.Context, id string) (Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssueByID, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Priority,
		&i.Status,
		&i.Assignee,
		&i.ProjectID,
		&i.TeamID,
		&i.StartDate,
		&i.EndDate,
		&i.Label,
		&i.OwnerID,
	)
	return i, err
}

const getIssueByUserID = `-- name: GetIssueByUserID :many
SELECT i.id, i.title, i.content, i.priority, i.status, i.assignee, i.project_id, i.team_id, i.start_date, i.end_date, i.label, i.owner_id
FROM issues i
JOIN issue_assignees ia ON i.id = ia.issue_id
WHERE ia.user_id = ?
`

func (q *Queries) GetIssueByUserID(ctx context.Context, userID string) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, getIssueByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Priority,
			&i.Status,
			&i.Assignee,
			&i.ProjectID,
			&i.TeamID,
			&i.StartDate,
			&i.EndDate,
			&i.Label,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssigneesByIssueID = `-- name: ListAssigneesByIssueID :many
SELECT u.id, u.username, u.password_hash, u.email, u.roles
FROM users u
JOIN issue_assignees ia ON u.id = ia.user_id
WHERE ia.issue_id = ?
`

func (q *Queries) ListAssigneesByIssueID(ctx context.Context, issueID string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listAssigneesByIssueID, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PasswordHash,
			&i.Email,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByProjectID = `-- name: ListIssuesByProjectID :many
SELECT id, title, content, priority, status, assignee, project_id, team_id, start_date, end_date, label, owner_id
FROM issues
WHERE project_id = ?
ORDER BY start_date DESC
`

func (q *Queries) ListIssuesByProjectID(ctx context.Context, projectID sql.NullString) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Priority,
			&i.Status,
			&i.Assignee,
			&i.ProjectID,
			&i.TeamID,
			&i.StartDate,
			&i.EndDate,
			&i.Label,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByTeamID = `-- name: ListIssuesByTeamID :many
SELECT id, title, content, priority, status, assignee, project_id, team_id, start_date, end_date, label, owner_id
FROM issues
WHERE team_id = ?
ORDER BY start_date DESC
`

func (q *Queries) ListIssuesByTeamID(ctx context.Context, teamID string) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByTeamID, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Priority,
			&i.Status,
			&i.Assignee,
			&i.ProjectID,
			&i.TeamID,
			&i.StartDate,
			&i.EndDate,
			&i.Label,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAssigneeFromIssue = `-- name: RemoveAssigneeFromIssue :exec
DELETE FROM issue_assignees
WHERE issue_id = ? AND user_id = ?
`

type RemoveAssigneeFromIssueParams struct {
	IssueID string `json:"issue_id"`
	UserID  string `json:"user_id"`
}

func (q *Queries) RemoveAssigneeFromIssue(ctx context.Context, arg RemoveAssigneeFromIssueParams) error {
	_, err := q.db.ExecContext(ctx, removeAssigneeFromIssue, arg.IssueID, arg.UserID)
	return err
}

const updateIssue = `-- name: UpdateIssue :exec
UPDATE issues
SET
    title = ?,
    content = ?,
    priority = ?,
    status = ?,
    project_id = ?,
    team_id = ?,
    start_date = ?,
    end_date = ?,
    label = ?,
    owner_id = ?
WHERE id = ?
`

type UpdateIssueParams struct {
	Title     string         `json:"title"`
	Content   sql.NullString `json:"content"`
	Priority  sql.NullString `json:"priority"`
	Status    string         `json:"status"`
	ProjectID sql.NullString `json:"project_id"`
	TeamID    string         `json:"team_id"`
	StartDate sql.NullTime   `json:"start_date"`
	EndDate   sql.NullTime   `json:"end_date"`
	Label     sql.NullString `json:"label"`
	OwnerID   string         `json:"owner_id"`
	ID        string         `json:"id"`
}

func (q *Queries) UpdateIssue(ctx context.Context, arg UpdateIssueParams) error {
	_, err := q.db.ExecContext(ctx, updateIssue,
		arg.Title,
		arg.Content,
		arg.Priority,
		arg.Status,
		arg.ProjectID,
		arg.TeamID,
		arg.StartDate,
		arg.EndDate,
		arg.Label,
		arg.OwnerID,
		arg.ID,
	)
	return err
}
